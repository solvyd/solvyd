package gitops
package gitops

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"time"

	"github.com/rs/zerolog/log"












































































































































































































































































































}	}		"dry_run":     s.cfg.Sync.DryRun,		"auto_apply":  s.cfg.Sync.AutoApply,		"last_commit": s.lastHash,		"last_sync":   s.lastSync,		"branch":      s.cfg.Repository.Branch,		"repository":  s.cfg.Repository.URL,		"enabled":     s.cfg.Enabled,	return map[string]interface{}{func (s *SyncService) GetStatus() map[string]interface{} {// GetStatus returns the current sync status}	return nil	}		// TODO: Parse YAML and apply to database		log.Debug().Str("file", file).Msg("Processing webhook configuration")	for _, file := range files {	log.Info().Int("count", len(files)).Msg("Applying webhooks from GitOps")	}		return err	if err != nil {	files, err := filepath.Glob(filepath.Join(webhooksPath, "*.yaml"))	}		return nil		log.Debug().Str("path", webhooksPath).Msg("Webhooks directory not found, skipping")	if _, err := os.Stat(webhooksPath); os.IsNotExist(err) {func (s *SyncService) applyWebhooks(webhooksPath string) error {// applyWebhooks applies webhook configurations}	return nil	}		// TODO: Parse YAML and apply to database		log.Debug().Str("file", file).Msg("Processing credential configuration")	for _, file := range files {	log.Info().Int("count", len(files)).Msg("Applying credentials from GitOps")	}		return err	if err != nil {	files, err := filepath.Glob(filepath.Join(credsPath, "*.yaml"))	}		return nil		log.Debug().Str("path", credsPath).Msg("Credentials directory not found, skipping")	if _, err := os.Stat(credsPath); os.IsNotExist(err) {func (s *SyncService) applyCredentials(credsPath string) error {// applyCredentials applies credential configurations}	return nil	}		// This will be implemented in the next iteration		// TODO: Parse YAML and apply to database		log.Debug().Str("file", file).Msg("Processing job configuration")	for _, file := range files {	log.Info().Int("count", len(files)).Msg("Applying jobs from GitOps")	}		return err	if err != nil {	files, err := filepath.Glob(filepath.Join(jobsPath, "*.yaml"))	}		return nil		log.Debug().Str("path", jobsPath).Msg("Jobs directory not found, skipping")	if _, err := os.Stat(jobsPath); os.IsNotExist(err) {func (s *SyncService) applyJobs(jobsPath string) error {// applyJobs applies job configurations}	return nil	}		}			return err		if !s.cfg.Sync.DryRun {		log.Error().Err(err).Msg("Failed to apply webhooks")	if err := s.applyWebhooks(filepath.Join(configPath, "webhooks")); err != nil {	// Apply webhooks	}		}			return err		if !s.cfg.Sync.DryRun {		log.Error().Err(err).Msg("Failed to apply credentials")	if err := s.applyCredentials(filepath.Join(configPath, "credentials")); err != nil {	// Apply credentials	}		}			return err		if !s.cfg.Sync.DryRun {		log.Error().Err(err).Msg("Failed to apply jobs")	if err := s.applyJobs(filepath.Join(configPath, "jobs")); err != nil {	// Apply jobs	configPath := filepath.Join(s.repoPath, s.cfg.Repository.Path)func (s *SyncService) applyConfiguration() error {// applyConfiguration applies the configuration from Git to database}	return s.cfg.Repository.URL	}		}			return "https://" + s.cfg.Authentication.Token + "@" + url[8:]		if len(url) > 8 && url[:8] == "https://" {		url := s.cfg.Repository.URL		// https://github.com/org/repo -> https://TOKEN@github.com/org/repo		// Insert token into HTTPS URL	if s.cfg.Authentication.Type == "token" && s.cfg.Authentication.Token != "" {func (s *SyncService) getAuthenticatedURL() string {// getAuthenticatedURL returns the Git URL with authentication}	return string(output[:40]), nil // First 40 chars = full SHA	}		return "", fmt.Errorf("failed to get commit hash: %w", err)	if err != nil {	output, err := cmd.Output()	cmd.Dir = s.repoPath	cmd := exec.Command("git", "rev-parse", "HEAD")func (s *SyncService) getCurrentCommit() (string, error) {// getCurrentCommit gets the current commit hash}	return nil	}		return fmt.Errorf("git pull failed: %w, output: %s", err, output)	if err != nil {	output, err := cmd.CombinedOutput()	cmd.Dir = s.repoPath	cmd := exec.Command("git", "pull", "--rebase")func (s *SyncService) pullRepository() error {// pullRepository pulls latest changes}	return nil	}		return fmt.Errorf("git clone failed: %w, output: %s", err, output)	if err != nil {	output, err := cmd.CombinedOutput()	)		s.repoPath,		s.getAuthenticatedURL(),		"--depth", "1",		"--branch", s.cfg.Repository.Branch,	cmd := exec.Command("git", "clone",	os.RemoveAll(s.repoPath)	// Remove existing directory if it existsfunc (s *SyncService) cloneRepository() error {// cloneRepository clones the Git repository}	return s.pullRepository()	log.Debug().Msg("Pulling latest changes")	// Repository exists, pull latest changes	}		return s.cloneRepository()		log.Info().Str("path", s.repoPath).Msg("Cloning GitOps repository")		// Repository doesn't exist, clone it	if _, err := os.Stat(filepath.Join(s.repoPath, ".git")); os.IsNotExist(err) {func (s *SyncService) cloneOrPull() error {// cloneOrPull clones the repository or pulls latest changes}	return nil		Msg("GitOps sync completed successfully")		Time("sync_time", s.lastSync).		Str("commit", hash).	log.Info().	s.lastSync = time.Now()	s.lastHash = hash	}		return fmt.Errorf("failed to apply configuration: %w", err)	if err := s.applyConfiguration(); err != nil {	// Apply configuration		Msg("Changes detected, applying configuration")		Str("new_commit", hash).		Str("old_commit", s.lastHash).	log.Info().	}		return nil		log.Debug().Msg("No changes detected, skipping sync")	if hash == s.lastHash {	// Check if anything changed	}		return fmt.Errorf("failed to get current commit: %w", err)	if err != nil {	hash, err := s.getCurrentCommit()	// Get current commit hash	}		return fmt.Errorf("failed to clone/pull repository: %w", err)	if err := s.cloneOrPull(); err != nil {	// Clone or pull repository	log.Info().Msg("Starting GitOps sync")func (s *SyncService) Sync() error {// Sync performs a synchronization from Git to database}	}		}			}				log.Error().Err(err).Msg("GitOps sync failed")			if err := s.Sync(); err != nil {		case <-ticker.C:			return		case <-s.ctx.Done():		select {	for {	defer ticker.Stop()	ticker := time.NewTicker(time.Duration(s.cfg.Sync.Interval) * time.Second)func (s *SyncService) syncLoop() {// syncLoop runs periodic synchronization}	s.cancel()	log.Info().Msg("Stopping GitOps sync service")func (s *SyncService) Stop() {// Stop stops the sync service}	return nil	go s.syncLoop()	// Start periodic sync	}		return err		log.Error().Err(err).Msg("Initial GitOps sync failed")	if err := s.Sync(); err != nil {	// Initial sync		Msg("Starting GitOps sync service")		Int("interval", s.cfg.Sync.Interval).		Str("branch", s.cfg.Repository.Branch).		Str("repo", s.cfg.Repository.URL).	log.Info().	}		return nil		log.Info().Msg("GitOps sync disabled")	if !s.cfg.Enabled {func (s *SyncService) Start() error {// Start begins the GitOps synchronization loop}	}		cancel:   cancel,		ctx:      ctx,		repoPath: filepath.Join(os.TempDir(), "ritmo-gitops-repo"),		db:       db,		cfg:      cfg,	return &SyncService{	ctx, cancel := context.WithCancel(context.Background())func NewSyncService(cfg *config.GitOpsConfig, db *database.Database) *SyncService {// NewSyncService creates a new GitOps sync service}	cancel    context.CancelFunc	ctx       context.Context	lastHash  string	lastSync  time.Time	repoPath  string	db        *database.Database	cfg       *config.GitOpsConfigtype SyncService struct {// SyncService handles GitOps synchronization)	"github.com/vrenjith/ritmo/api-server/internal/database"	"github.com/vrenjith/ritmo/api-server/internal/config"